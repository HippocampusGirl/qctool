
//          Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)


#include <vector>
#include <unordered_map>
#include <ctime>
#include <boost/function.hpp>
#include <boost/format.hpp>
#include <boost/filesystem.hpp>
#include <boost/functional/hash.hpp>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/discrete_distribution.hpp>

#include "config/qctool_version_autogenerated.hpp"

#include "metro/ShotgunStochasticSearch.hpp"

#include "appcontext/CmdLineOptionProcessor.hpp"
#include "appcontext/ApplicationContext.hpp"

#include "genfile/MissingValue.hpp"
#include "genfile/bgen/View.hpp"
#include "genfile/bgen/Query.hpp"
#include "genfile/SNPDataSource.hpp"
#include "genfile/ToGP.hpp"

#include "metro/regression/LogPosteriorDensity.hpp"

namespace bfs = boost::filesystem ;

#define DEBUG 1

namespace globals {
	std::string const program_name = "multifinemap" ;
	std::string const program_version = qctool_version ;
	std::string const program_revision =  std::string( qctool_revision ).substr( 0, 7 ) ;
}

namespace {
	std::ostream& operator<<( std::ostream& out, std::vector< std::size_t > const& states ) {
		out << "[" ;
		for( std::size_t j = 0; j < states.size(); ++j ) {
			out << ((j>0)?",":"") << states[j] ;
		}
		return out << "]" ;
	}

	std::string print_state( std::size_t N, std::vector< std::size_t > const& states ) {
		std::string result = "[";
		std::size_t begin = 0 ;
		for( std::size_t i = 0; i <= states.size(); ++i ) {
			std::size_t end = (i==states.size()) ? N : states[i] ;
			for( std::size_t j = begin; j < end; ++j ) {
				result.push_back( '0' ) ;
			}
			if( end != N ) {
				result.push_back( '1' ) ;
			}
			begin = end+1 ;
		}
		result += ']' ;
		return result ;
	}
}

struct MFMOptions: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		options.set_spec_option( "-spec" ) ;

		// File options
		options.declare_group( "Input file options" ) ;
	    options[ "-g" ]
	        .set_description( 	"Path to BGEN file giving genotypes." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1 ) ;
	    options[ "-assume-chromosome" ]
	        .set_description( "Chromosome to assume if not in genetic data." )
			.set_takes_single_value() ;
	    options[ "-s" ]
	        .set_description( "Path of sample file to input.  If specified, this option must occur as often as the -g option"
							" to specify one sample file per cohort." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 1000 ) ;
		options[ "-incl-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to operate on. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_values_until_next_option() ;
		options[ "-excl-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to exclude from operation. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_values_until_next_option() ;
		options[ "-phenotype" ]
			.set_description( "Name of phenotype in sample file" )
			.set_takes_single_value() ;
		
		options.declare_group( "Model options" ) ;
		options[ "-incl-samples"]
			.set_description( "Filter out samples whose sample ID does not lie in the given file(s).")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-samples"]
			.set_description( "Filter out samples whose sample ID lies in the given file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-samples-where"]
			.set_description( "Include samples by specifying conditions on the values of columns in the sample file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-samples-where"]
			.set_description( "Exclude samples by specifying conditions on the values of columns in the sample file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-minimum-allele-count" ]
			.set_description( "Skip predictors that have less than this minor allele count" )
			.set_takes_values(1)
			.set_default_value( 10 ) ;
		options[ "-prior" ]
			.set_description( "Specify a prior for bayesian computation."
				"Prior spec should be in the form <parameter name>~<distribution family>(parameters)."
				"(It is recommended to put single quotes round the whole argument to protect from shell expansion.)"
				"Currently, logF and gaussian priors are supported."
			)
			.set_takes_values_until_next_option()
			.set_default_value( "add/[outcome]=1~logf(2,2)" )
			.set_default_value( "overdominance/[outcome]=1~logf(4,4)" )
			.set_default_value( "het/[outcome]=1~logf(2,2)" )
			.set_default_value( "dom/[outcome]=1~logf(2,2)" )
			.set_default_value( "rec/[outcome]=1~logf(2,2)" )
		;
		options[ "-covariates" ]
			.set_description( "Specify the name of one or more covariates to include in the model."
				" These must be columns named in the sample file." )
			.set_takes_values_until_next_option() ;
			
		options.declare_group( "Model fitting options" ) ;
		options[ "-tolerance" ]
			.set_description( "Tolerance" )
			.set_takes_values(1)
			.set_default_value( 0.001 ) ;
		options[ "-max-iterations" ]
			.set_description( "Maximum fitting iterations" )
			.set_takes_values(1)
			.set_default_value( 100 ) ;

		options.declare_group( "Miscellaneous options" ) ;
		options[ "-analysis-name" ]
			.set_description( "Specify a name to label results from this analysis with." )
			.set_takes_single_value()
			.set_default_value( "qctool analysis" ) ;
		options[ "-analysis-chunk" ]
			.set_description( "Specify a name denoting the current genomic region or chunk on which this is run.  This is intended for use in parallel environments." )
			.set_takes_single_value()
			.set_default_value( genfile::MissingValue() ) ;
		options.declare_group( "Miscellaneous options" ) ;
		options[ "-debug" ]
			.set_description( "Output debugging information." ) ;
	}
} ;

struct DosageStore {

public:
	typedef boost::function< void( std::size_t const, boost::optional< std::size_t > const ) > ProgressCallback ;
	typedef std::unique_ptr< DosageStore > UniquePtr ;

	static UniquePtr create() {
		return UniquePtr( new DosageStore() ) ;
	}
public:
	DosageStore() {}
	
	void load( genfile::SNPDataSource::UniquePtr source, ProgressCallback callback ) {
		load_unsafe( *source, callback ) ;
	}
	
	std::size_t estimate_memory_usage() const {
		std::size_t result = 0 ;
		for( std::size_t i = 0; i < m_variants.size(); ++i ) {
			result += m_variants[i].estimate_bytes_used() ;
			result += m_ploidy[i].size() ;
			result += m_AB[i].size() ;
			result += m_BB[i].size() ;
		}
		return result ;
	}
	
	std::string get_summary() const {
		using boost::format ;
		return (
			boost::format( "DosageStore: %d variants, %d samples, approx %.2fMb memory usage.\n" )
				% m_variants.size()
				% (m_variants.size() > 0 ? m_AB[0].size() : 0 )
				% (estimate_memory_usage() / 1000000.0)
		).str() ;
	}

private:

	/* Store genotype probabilities in 8 bit, BGEN-like encoding */
	struct DosageSetter {
		DosageSetter(
			std::vector< uint8_t >* ploidy,
			std::vector< uint8_t >* AB,
			std::vector< uint8_t >* BB
		):
			m_ploidy( ploidy ),
			m_AB( AB ),
			m_BB( BB ),
			m_bits(8),
			m_constant( double(0xFFFFFFFF >> (32 - m_bits))),
			m_sample_i(0),
			m_order_type( genfile::eUnknownOrderType )
		{}
		
		void initialise( std::size_t nSamples, std::size_t nAlleles ) {
			assert( nAlleles == 2 ) ;
			m_ploidy->resize( nSamples ) ;
			std::fill( m_ploidy->begin(), m_ploidy->end(), 0x80 ) ;
			m_AB->resize( nSamples ) ;
			std::fill( m_AB->begin(), m_AB->end(), 0 ) ;
			m_BB->resize( nSamples ) ;
			std::fill( m_BB->begin(), m_BB->end(), 0 ) ;
		}

		bool set_sample( std::size_t n ) {
			m_sample_i = n ;
			m_order_type = genfile::eUnknownOrderType ;
			return true ;
		}

		void set_number_of_entries(
			uint32_t ploidy, std::size_t n,
			genfile::OrderType const order_type,
			genfile::ValueType const value_type
		) {
			assert( ploidy <= 2 ) ;
			assert( (order_type == genfile::ePerOrderedHaplotype || genfile::ePerUnorderedGenotype) && value_type == genfile::eProbability ) ;
			(*m_ploidy)[m_sample_i] = ploidy ;
			m_order_type = order_type ;
		}

		void set_value( std::size_t entry_i, genfile::MissingValue const value ) {
			uint8_t& ploidy = (*m_ploidy)[m_sample_i] ;
			uint8_t& AB = (*m_AB)[m_sample_i] ;
			uint8_t& BB = (*m_BB)[m_sample_i] ;
			ploidy |= 0x80 ;
			AB = BB = 0 ;
		}

		void set_value( std::size_t entry_i, double const value ) {
			uint8_t& ploidy = (*m_ploidy)[m_sample_i] ;
			uint8_t& AB = (*m_AB)[m_sample_i] ;
			uint8_t& BB = (*m_BB)[m_sample_i] ;

			if( !(ploidy & 0x80) ) {
				if( entry_i == 1 ) {
					AB = value / m_constant ;
				} else if (entry_i == 1 ) {
					BB = value / m_constant ;
				}
			}
		}

		void set_value( std::size_t entry_i, genfile::Integer const value ) {
			assert(0) ; // expecting GT field
		}

		void finalise() {
			// nothing to do
		}
		private:
			std::vector< uint8_t >* m_ploidy ;
			std::vector< uint8_t >* m_AB ;
			std::vector< uint8_t >* m_BB ;
			uint32_t m_bits ;
			double m_constant ;
			std::size_t m_sample_i ;
			genfile::OrderType m_order_type ;
	} ;

	void load_unsafe( genfile::SNPDataSource& source, ProgressCallback callback ) {
		if( source.total_number_of_snps() ) {
			std::size_t N = *source.total_number_of_snps() ;
			m_variants.reserve( N ) ;
			m_ploidy.reserve( N ) ;
			m_AB.reserve( N ) ;
			m_BB.reserve( N ) ;
		}

		genfile::VariantIdentifyingData variant ;
		std::vector< uint16_t > data ;
		std::size_t count = 0 ;
		std::vector< uint8_t > ploidy, AB, BB ;
		
		
		while( source.get_snp_identifying_data( &variant )) {
			// ok, read dosages.
			DosageSetter setter( &ploidy, &AB, &BB ) ;
			source.read_variant_data()->get( ":genotypes:", genfile::to_GP_unphased( setter ) ) ;
			m_variants.push_back( variant ) ;
			m_ploidy.push_back( ploidy ) ;
			m_AB.push_back( AB ) ;
			m_BB.push_back( BB ) ;
			//m_data.push_back( data ) ;
			if( callback ) {
				callback( ++count, source.total_number_of_snps() ) ;
			}
		}
	}
	
	std::vector< genfile::VariantIdentifyingData > m_variants ;
	// To avoid using too much space, we encode dosage data as 16-bit integer
	// and expand to required format when requested.
	std::vector< std::vector< uint8_t > > m_ploidy ;
	std::vector< std::vector< uint8_t > > m_AB ;
	std::vector< std::vector< uint8_t > > m_BB ;
} ;

struct MFMApplication: public appcontext::ApplicationContext {
	MFMApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new MFMOptions ),
			argc,
			argv,
			"-log"
		)
	{
		process() ;
	}
	
private:
	
	void process() {
		unsafe_process() ;
	}
	
	void unsafe_process() {
		DosageStore::UniquePtr store = load_data() ;
	
		metro::regression::LogPosteriorDensity::UniquePtr
			ll = create_loglikelihood() ;
	
		run_search( *store, *ll ) ;
	}
	
	DosageStore::UniquePtr load_data() {
		appcontext::UIContext::ProgressContext progress_context = ui().get_progress_context( "Loading data" ) ;
		DosageStore::UniquePtr store = DosageStore::create() ;
		genfile::Chromosome hint ;
		if( options().check( "-assume-chromosome" ) ) {
			hint = options().get< std::string >( "-assume-chromosome" ) ;
		}
		store->load(
			genfile::SNPDataSource::create( options().get< std::string >( "-g" ), hint ),
			progress_context
		) ;
		ui().logger() << store->get_summary() ;
		return store ;
	}
	
	metro::regression::LogPosteriorDensity::UniquePtr create_loglikelihood() {
		assert(0) ;
		//return metro::regression::LogPosteriorDensity::UniquePtr ;
	}

	metro::regression::LogLikelihood::UniquePtr create_loglikelihood( metro::regression::Design& design ) const {
		//metro::regression::LogLikelihood::UniquePtr ll( metro::regression::BinomialLogistic::create( design ).release() ) ;
		//ll = apply_priors( ll, options().get_values< std::string>( "-prior" )) ;
		//return metro::regression::LogLikelihood::UniquePtr( ll.release() ) ;
	}

	void run_search( DosageStore& store, metro::regression::LogPosteriorDensity& posterior ) {
		// Do a test search for now
		metro::ShotgunStochasticSearch ss(
			10,
			[]( metro::ShotgunStochasticSearch::SelectedStates const& s ) {
				std::cerr << "attempt: " << print_state( 10, s ) << "\n" ;
				return 10.0 - 10 * s.size() ;
			},
			static_cast<std::uint32_t>(std::time(0))
		) ;


		for( std::size_t i = 0; i < 3; ++i ) {
			metro::ShotgunStochasticSearch::SelectedStates const& pick = ss.update() ;
			std::cerr << " Picked: " << print_state( 10, pick ) << "\n" ;
		}
	}
	

	void create_query( genfile::bgen::Query* query ) {
		if( options().check( "-incl-range" )) {
			auto const elts = options().get_values< std::string >( "-incl-range" ) ;
			for( std::string const& elt: elts ) {
				query->include_range( parse_range( elt )) ;
			}
		}
		if( options().check( "-excl-range" )) {
			auto const elts = options().get_values< std::string >( "-excl-range" ) ;
			for( std::string const& elt: elts ) {
				query->exclude_range( parse_range( elt )) ;
			}
		}
		if( options().check( "-incl-rsids" )) {
			auto const ids = options().get_values< std::string >( "-incl-rsids" ) ;
			query->include_rsids( ids ) ;
		}

		if( options().check( "-excl-rsids" )) {
			auto const ids = options().get_values< std::string >( "-excl-rsids" ) ;
			query->exclude_rsids( ids ) ;
		}
	}
	
	genfile::bgen::IndexQuery::GenomicRange parse_range( std::string const& spec ) const {
		std::size_t colon_pos = spec.find( ':' ) ;
		if ( colon_pos == std::string::npos ) {
			throw std::invalid_argument( "spec=\"" + spec + "\"" ) ;
		}

		std::vector< std::string > pieces ;
		pieces.push_back( spec.substr( 0, colon_pos )) ;
		pieces.push_back( spec.substr( colon_pos+1, spec.size() )) ;

		if( pieces.size() != 2 ) {
			throw std::invalid_argument( "spec=\"" + spec + "\"" ) ;
		}

		std::size_t separator_pos = pieces[1].find( '-' ) ;
		if ( separator_pos == std::string::npos ) {
			throw std::invalid_argument( "spec=\"" + spec + "\"" ) ;
		}

		std::string chromosome( pieces[0] ) ;
		int pos1 = (separator_pos == 0) ? 0 : std::stoi( pieces[1].substr( 0, separator_pos ) ) ;
		int pos2 = (separator_pos == (pieces[1].size()-1)) ? std::numeric_limits< int >::max() : std::stoi( pieces[1].substr( separator_pos + 1, pieces[1].size() ) ) ;
		assert( pos1 >= 0 ) ;
		assert( pos2 >= pos1 ) ;

		return genfile::bgen::IndexQuery::GenomicRange( chromosome, pos1, pos2 ) ;
	}
} ;

int main( int argc, char** argv ) {
	try {
		MFMApplication app( argc, argv ) ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}

