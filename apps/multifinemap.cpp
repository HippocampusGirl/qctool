
//          Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)


#include <vector>
#include <unordered_map>
#include <ctime>
#include <boost/function.hpp>
#include <boost/format.hpp>
#include <boost/filesystem.hpp>
#include <boost/functional/hash.hpp>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/discrete_distribution.hpp>

#include "config/qctool_version_autogenerated.hpp"

#include "metro/ShotgunStochasticSearch.hpp"
#include "metro/regression/Design.hpp"
#include "metro/regression/Logistic.hpp"
#include "metro/IndependentParameterDistribution.hpp"
#include "metro/distributions/LogF.hpp"
#include "metro/distributions/Flat.hpp"
#include "metro/regression/LogUnnormalisedPosterior.hpp"
#include "metro/intersect_ranges.hpp"
#include "metro/regression/fit_model.hpp"
#include "metro/SampleRange.hpp"

#include "appcontext/CmdLineOptionProcessor.hpp"
#include "appcontext/ApplicationContext.hpp"

#include "genfile/MissingValue.hpp"
#include "genfile/bgen/View.hpp"
#include "genfile/bgen/Query.hpp"
#include "genfile/SNPDataSource.hpp"
#include "genfile/ToGP.hpp"

namespace bfs = boost::filesystem ;

#define DEBUG 1
// #define DEBUG_DOSAGESTORE 1

namespace globals {
	std::string const program_name = "multifinemap" ;
	std::string const program_version = qctool_version ;
	std::string const program_revision =  std::string( qctool_revision ).substr( 0, 7 ) ;
}

namespace {
	std::ostream& operator<<( std::ostream& out, std::vector< std::size_t > const& states ) {
		out << "[" ;
		for( std::size_t j = 0; j < states.size(); ++j ) {
			out << ((j>0)?",":"") << states[j] ;
		}
		return out << "]" ;
	}

	std::string print_state( std::size_t N, std::vector< std::size_t > const& states ) {
		std::string result = "[";
		std::size_t begin = 0 ;
		for( std::size_t i = 0; i <= states.size(); ++i ) {
			std::size_t end = (i==states.size()) ? N : states[i] ;
			for( std::size_t j = begin; j < end; ++j ) {
				result.push_back( '0' ) ;
			}
			if( end != N ) {
				result.push_back( '1' ) ;
			}
			begin = end+1 ;
		}
		result += ']' ;
		return result ;
	}
}

struct MFMOptions: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		options.set_spec_option( "-spec" ) ;

		// File options
		options.declare_group( "Input file options" ) ;
	    options[ "-g" ]
	        .set_description( 	"Path to BGEN file giving genotypes." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1 ) ;
	    options[ "-assume-chromosome" ]
	        .set_description( "Chromosome to assume if not in genetic data." )
			.set_takes_single_value() ;
	    options[ "-s" ]
	        .set_description( "Path of sample file to input.  If specified, this option must occur as often as the -g option"
							" to specify one sample file per cohort." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 1000 ) ;
		options[ "-incl-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to operate on. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_values_until_next_option() ;
		options[ "-excl-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to exclude from operation. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_values_until_next_option() ;
		options[ "-phenotype" ]
			.set_description( "Name of phenotype in sample file" )
			.set_takes_single_value() ;
		
		options.declare_group( "Model options" ) ;
		options[ "-incl-samples"]
			.set_description( "Filter out samples whose sample ID does not lie in the given file(s).")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-samples"]
			.set_description( "Filter out samples whose sample ID lies in the given file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-samples-where"]
			.set_description( "Include samples by specifying conditions on the values of columns in the sample file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-samples-where"]
			.set_description( "Exclude samples by specifying conditions on the values of columns in the sample file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-minimum-allele-count" ]
			.set_description( "Skip predictors that have less than this minor allele count" )
			.set_takes_values(1)
			.set_default_value( 10 ) ;
		options[ "-prior" ]
			.set_description( "Specify a prior for bayesian computation."
				"Prior spec should be in the form <parameter name>~<distribution family>(parameters)."
				"(It is recommended to put single quotes round the whole argument to protect from shell expansion.)"
				"Currently, logF and gaussian priors are supported."
			)
			.set_takes_values_until_next_option()
			.set_default_value( "add/[outcome]=1~logf(2,2)" )
			.set_default_value( "overdominance/[outcome]=1~logf(4,4)" )
			.set_default_value( "het/[outcome]=1~logf(2,2)" )
			.set_default_value( "dom/[outcome]=1~logf(2,2)" )
			.set_default_value( "rec/[outcome]=1~logf(2,2)" )
		;
		options[ "-covariates" ]
			.set_description( "Specify the name of one or more covariates to include in the model."
				" These must be columns named in the sample file." )
			.set_takes_values_until_next_option() ;
			
		options.declare_group( "Model fitting options" ) ;
		options[ "-tolerance" ]
			.set_description( "Tolerance" )
			.set_takes_values(1)
			.set_default_value( 0.001 ) ;
		options[ "-max-iterations" ]
			.set_description( "Maximum fitting iterations" )
			.set_takes_values(1)
			.set_default_value( 100 ) ;

		options.declare_group( "Miscellaneous options" ) ;
		options[ "-analysis-name" ]
			.set_description( "Specify a name to label results from this analysis with." )
			.set_takes_single_value()
			.set_default_value( "qctool analysis" ) ;
		options[ "-analysis-chunk" ]
			.set_description( "Specify a name denoting the current genomic region or chunk on which this is run.  This is intended for use in parallel environments." )
			.set_takes_single_value()
			.set_default_value( genfile::MissingValue() ) ;
		options.declare_group( "Miscellaneous options" ) ;
		options[ "-debug" ]
			.set_description( "Output debugging information." ) ;
	}
} ;

struct DosageStore {
public:
	typedef boost::function< void( std::size_t const, boost::optional< std::size_t > const ) > ProgressCallback ;
	typedef std::unique_ptr< DosageStore > UniquePtr ;

	static UniquePtr create() {
		return UniquePtr( new DosageStore() ) ;
	}
public:
	DosageStore() {}
	
	void load( genfile::SNPDataSource::UniquePtr source, ProgressCallback callback ) {
		load_unsafe( *source, callback ) ;
	}
	
	std::size_t number_of_samples() const { return m_ploidy[0].size() ; }
	std::size_t number_of_variants() const { return m_variants.size() ; }
	
	std::size_t estimate_memory_usage() const {
		std::size_t result = 0 ;
		for( std::size_t i = 0; i < m_variants.size(); ++i ) {
			result += m_variants[i].estimate_bytes_used() ;
			result += m_ploidy[i].size() ;
			result += m_AB[i].size() ;
			result += m_BB[i].size() ;
		}
		return result ;
	}
	
	std::string get_summary() const {
		using boost::format ;
		return (
			boost::format( "DosageStore: %d variants, %d samples, approx %.2fMb memory usage.\n" )
				% m_variants.size()
				% (m_variants.size() > 0 ? m_AB[0].size() : 0 )
				% (estimate_memory_usage() / 1000000.0)
		).str() ;
	}
	
	genfile::VariantIdentifyingData const get_variant( std::size_t i ) const {
		assert( i < m_variants.size() ) ;
		return m_variants[i] ;
	}
	
	template< typename Callback >
	void get_dosages( std::size_t i, Callback callback ) const {
		assert( i < m_variants.size() ) ;
		double const constant = double(0xFFFFFFFF >> 24) ;
		assert( i < m_variants.size() ) ;
		for( std::size_t j = 0; j < m_AB[i].size(); ++j ) {
			// unpack 8 bit bgen encoding
#if DEBUG_DOSAGESTORE
			if( j < 10 ) {
				std::cerr << "get_dosages(): " << j << ": " << int( m_AB[i][j] ) << ", " << int( m_BB[i][j] ) << ".\n" ;
			}
#endif
			callback( j, double( m_AB[i][j] ) / constant, double( m_BB[i][j] ) / constant ) ;
		}
	}
	
	std::vector< metro::SampleRange > const nonmissing_samples( std::size_t i ) const {
		assert( i < m_variants.size() ) ;
		return m_nonmissing_samples[i] ;
	}

private:

	/* Store genotype probabilities in 8 bit, BGEN-like encoding */
	struct DosageSetter {
		DosageSetter(
			std::vector< uint8_t >* ploidy,
			std::vector< uint8_t >* AB,
			std::vector< uint8_t >* BB
		):
			m_ploidy( ploidy ),
			m_AB( AB ),
			m_BB( BB ),
			m_bits(8),
			m_constant( double(0xFFFFFFFF >> (32 - m_bits))),
			m_sample_i(0),
			m_order_type( genfile::eUnknownOrderType )
		{}
		
		void initialise( std::size_t nSamples, std::size_t nAlleles ) {
			assert( nAlleles == 2 ) ;
			m_ploidy->resize( nSamples ) ;
			std::fill( m_ploidy->begin(), m_ploidy->end(), 0x80 ) ;
			m_AB->resize( nSamples ) ;
			std::fill( m_AB->begin(), m_AB->end(), 0 ) ;
			m_BB->resize( nSamples ) ;
			std::fill( m_BB->begin(), m_BB->end(), 0 ) ;
			m_last_nonmissing_sample_i = 0 ;
		}

		bool set_sample( std::size_t n ) {
			m_sample_i = n ;
			m_order_type = genfile::eUnknownOrderType ;
			return true ;
		}

		void set_number_of_entries(
			uint32_t ploidy, std::size_t n,
			genfile::OrderType const order_type,
			genfile::ValueType const value_type
		) {
			assert( ploidy <= 2 ) ;
			assert( (order_type == genfile::ePerOrderedHaplotype || genfile::ePerUnorderedGenotype) && value_type == genfile::eProbability ) ;
			(*m_ploidy)[m_sample_i] = ploidy ;
			m_order_type = order_type ;
		}

		void set_value( std::size_t entry_i, genfile::MissingValue const value ) {
			uint8_t& ploidy = (*m_ploidy)[m_sample_i] ;
			uint8_t& AB = (*m_AB)[m_sample_i] ;
			uint8_t& BB = (*m_BB)[m_sample_i] ;
			ploidy |= 0x80 ;
			AB = BB = 0 ;
			record_missing_sample( m_sample_i ) ;
		}

		void set_value( std::size_t entry_i, double const value ) {
			uint8_t& ploidy = (*m_ploidy)[m_sample_i] ;
			uint8_t& AB = (*m_AB)[m_sample_i] ;
			uint8_t& BB = (*m_BB)[m_sample_i] ;

#if DEBUG_DOSAGESTORE
			if( m_sample_i < 10 ) {
				std::cerr << "DosageSetter::set_value(): " << m_sample_i << ", " << entry_i << ": " << value << ".\n" ;
			}
#endif
			if( !(ploidy & 0x80) ) {
				if( entry_i == 1 ) {
					AB = value * m_constant ;
				} else if (entry_i == 2 ) {
					BB = value * m_constant ;
				}
			}
		}

		void set_value( std::size_t entry_i, genfile::Integer const value ) {
			assert(0) ; // expecting GT field
		}

		void finalise() {
			// add the final sample range if needed.
			record_missing_sample( m_ploidy->size() ) ;
		}
		
		std::vector< metro::SampleRange > const nonmissing_samples() { return m_nonmissing_samples ; }
		
		private:
			std::vector< uint8_t >* m_ploidy ;
			std::vector< uint8_t >* m_AB ;
			std::vector< uint8_t >* m_BB ;
			uint32_t m_bits ;
			double m_constant ;
			std::size_t m_sample_i ;
			std::size_t m_last_nonmissing_sample_i ;
			genfile::OrderType m_order_type ;
			std::vector< metro::SampleRange > m_nonmissing_samples ;
			
		void record_missing_sample( std::size_t sample_i ) {
			if( sample_i >= m_last_nonmissing_sample_i ) {
				m_nonmissing_samples.push_back(
					metro::SampleRange( m_last_nonmissing_sample_i, m_sample_i )
				) ;
			}
			m_last_nonmissing_sample_i = sample_i + 1 ;
		}
	} ;

	void load_unsafe( genfile::SNPDataSource& source, ProgressCallback callback ) {
		if( source.total_number_of_snps() ) {
			std::size_t N = *source.total_number_of_snps() ;
			m_variants.reserve( N ) ;
			m_ploidy.reserve( N ) ;
			m_AB.reserve( N ) ;
			m_BB.reserve( N ) ;
		}

		genfile::VariantIdentifyingData variant ;
		std::vector< uint16_t > data ;
		std::size_t count = 0 ;
		std::vector< uint8_t > ploidy, AB, BB ;
		
		while( source.get_snp_identifying_data( &variant )) {
			// ok, read dosages.
			std::cerr << "LOADING " << variant << ".\n" ;
			DosageSetter setter( &ploidy, &AB, &BB ) ;
			source.read_variant_data()->get( ":genotypes:", genfile::to_GP_unphased( setter ) ) ;
			m_variants.push_back( variant ) ;
			m_nonmissing_samples.push_back( setter.nonmissing_samples() ) ;
			m_ploidy.push_back( ploidy ) ;
			m_AB.push_back( AB ) ;
			m_BB.push_back( BB ) ;
			//m_data.push_back( data ) ;
			if( callback ) {
				callback( ++count, source.total_number_of_snps() ) ;
			}
		}
	}
	
	std::vector< genfile::VariantIdentifyingData > m_variants ;
	// To avoid using too much space, we encode dosage data as 16-bit integer
	// and expand to required format when requested.
	std::vector< std::vector< metro::SampleRange > > m_nonmissing_samples ;
	std::vector< std::vector< uint8_t > > m_ploidy ;
	std::vector< std::vector< uint8_t > > m_AB ;
	std::vector< std::vector< uint8_t > > m_BB ;
} ;

struct MFMApplication: public appcontext::ApplicationContext {
	MFMApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new MFMOptions ),
			argc,
			argv,
			"-log"
		)
	{
		process() ;
	}
	
private:
	
	void process() {
		try {
			unsafe_process() ;
		} catch( genfile::InputError const& e ) {
			get_ui_context().logger() << "!! Error (" << e.what() << "): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileNotFoundError const& e ) {
			get_ui_context().logger() << "\nError: No file matching \"" << e.filespec() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::db::Error const& e ) {
			get_ui_context().logger() << "!! Error (" << e.what() << ") with the following statement: \""
				<< e.sql()
				<< "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	void unsafe_process() {
		DosageStore::UniquePtr store = load_data() ;
	
		metro::regression::LogLikelihood::UniquePtr
			ll = create_loglikelihood( store->number_of_samples() ) ;
	
		run_search( *store, *ll ) ;
	}
	
	DosageStore::UniquePtr load_data() {
		appcontext::UIContext::ProgressContext progress_context = ui().get_progress_context( "Loading data" ) ;
		DosageStore::UniquePtr store = DosageStore::create() ;
		genfile::Chromosome hint ;
		if( options().check( "-assume-chromosome" ) ) {
			hint = options().get< std::string >( "-assume-chromosome" ) ;
		}
		store->load(
			genfile::SNPDataSource::create( options().get< std::string >( "-g" ), hint ),
			progress_context
		) ;
		ui().logger() << store->get_summary() ;
		return store ;
	}
	
	metro::regression::LogLikelihood::UniquePtr create_loglikelihood( std::size_t number_of_samples ) {
		typedef std::vector< std::string > Names ;
		typedef std::vector< metro::SampleRange > SampleRanges ;
		using namespace metro::regression ;
		Eigen::MatrixXd outcome = Eigen::MatrixXd::Zero( number_of_samples, 2 ) ;

		// Put in at least some nontrivial outcome.
		outcome.col(1).setConstant(1) ;
		outcome(1,0) = 1 ;
		outcome(1,1) = 0 ;

		Design::UniquePtr design = Design::create(
			outcome, SampleRanges(), Names({ "outcome=0", "outcome=1"} ),
			Names({
				"het1", "hom1",
				"het2", "hom2",
				"het3", "hom3",
				"het4", "hom4",
				"het5", "hom5"
			})
		) ;
		LogLikelihood::UniquePtr ll( metro::regression::Logistic::create( design ).release() ) ;
		std::cerr << ll->design().get_summary() << "\n" ;
		return ll ;
	}


	double test_variant(
		metro::ShotgunStochasticSearch::SelectedStates const& pick,
		DosageStore const& store,
		metro::regression::LogLikelihood& ll
	) {
		using namespace metro::regression ;
		using metro::SampleRange ;
		
		boost::format parameter_format( "%s%d/%s=1" ) ;
		
		assert( pick.size() < 6 ) ;
		Eigen::MatrixXd predictors = Eigen::MatrixXd::Zero( store.number_of_samples(), 10 ) ;
		std::vector< metro::SampleRange > nonmissing_samples( 1, metro::SampleRange( 0, store.number_of_samples() )) ;

		metro::IndependentParameterDistribution prior( ll.get_parameter_names() ) ;
		
		for( std::size_t i = 0; i < pick.size(); ++i ) {
			store.get_dosages(
				pick[i],
				[&predictors,i] ( int sample, double ab, double bb ){
					predictors( sample, i*2+0) = ab ;
					predictors( sample, i*2+1) = bb ;
				}
			) ;
			nonmissing_samples = metro::impl::intersect_ranges(
				nonmissing_samples,
				store.nonmissing_samples(pick[i])
			) ;
			prior.set_prior(
				(parameter_format % "het" % (i+1) % "outcome").str(),
				metro::distributions::LogF::create( 100, 100 )
			) ;
			prior.set_prior(
				(parameter_format % "hom" % (i+1) % "outcome").str(),
				metro::distributions::LogF::create( 100, 100 )
			) ;
		}
		
		ll.design().set_predictors( predictors, nonmissing_samples ) ;

		LogUnnormalisedPosterior posterior( ll, prior ) ;
		
		CholeskyStepper::Tracer tracer ;
		if( options().check( "-debug" )) {
			tracer = [this] ( 
				int iteration,
				double target_ll,
				CholeskyStepper::Vector const& point,
				CholeskyStepper::Vector const& first_derivative,
				CholeskyStepper::Vector const& step,
				bool converged
			) {
				this->get_ui_context().logger()
					<< " ITERATION:" << iteration << "\n"
					<< "    TARGET:" << target_ll << "\n"
					<< "     POINT:" << point.transpose() << "\n"
					<< "DERIVATIVE:" << first_derivative.transpose() << "\n"
					<< "      STEP:" << step.transpose() << "\n"
					<< " CONVERGED:" << ( converged ? "yes" : "no" ) << "\n" ;
			} ;
		}

		metro::regression::CholeskyStepper stopping_condition(
			0.01, //options().get_value< double >( "-tolerance" ),
			100, //options().get_value< double >( "-max-iterations" ),
			tracer
		) ;

		std::vector< std::string > comments ;

		std::pair< bool, int > result = metro::regression::fit_model(
			posterior,
			"full",
			Eigen::VectorXd::Zero( ll.identify_parameters().rows() ),
			stopping_condition,
			&comments
		) ;
		
		//posterior.evaluate_at( Eigen::VectorXd::Zero( ll.identify_parameters().rows() )) ;
#if DEBUG
		std::cerr << print_state( store.number_of_variants(), pick ) << ".\n" ;
		//std::cerr << nonmissing_samples << ".\n" ;
		// std::cerr << "PREDICTORS:\n" << predictors.block( 0, 0, 10, predictors.cols() ) << ".\n" ;
		std::cerr << posterior.get_summary() << "\n" ;
		std::cerr << "INCLUDED: " << posterior.ll().design().nonmissing_samples() << "\n" ;
		std::cerr << "  RESULT: " << posterior.get_value_of_function() << "\n" ;
		std::cerr << "\n+++++++++++++++++++++++++\n" ;
#endif		
		
		return posterior.get_value_of_function() ;
	}

	void run_search( DosageStore& store, metro::regression::LogLikelihood& ll ) {
		// Do a test search for now
		metro::ShotgunStochasticSearch ss(
			store.number_of_variants(),
			[this, &store, &ll]( metro::ShotgunStochasticSearch::SelectedStates const& s ) {
				return this->test_variant( s, store, ll ) ;
			},
			static_cast<std::uint32_t>(std::time(0))
		) ;

		for( std::size_t i = 0; i < 300; ++i ) {
			metro::ShotgunStochasticSearch::SelectedStates const& pick = ss.update() ;
			std::cerr << print_state( store.number_of_variants(), pick ) << ".\n" ;
		}
	}

	void create_query( genfile::bgen::Query* query ) {
		if( options().check( "-incl-range" )) {
			auto const elts = options().get_values< std::string >( "-incl-range" ) ;
			for( std::string const& elt: elts ) {
				query->include_range( parse_range( elt )) ;
			}
		}
		if( options().check( "-excl-range" )) {
			auto const elts = options().get_values< std::string >( "-excl-range" ) ;
			for( std::string const& elt: elts ) {
				query->exclude_range( parse_range( elt )) ;
			}
		}
		if( options().check( "-incl-rsids" )) {
			auto const ids = options().get_values< std::string >( "-incl-rsids" ) ;
			query->include_rsids( ids ) ;
		}

		if( options().check( "-excl-rsids" )) {
			auto const ids = options().get_values< std::string >( "-excl-rsids" ) ;
			query->exclude_rsids( ids ) ;
		}
	}
	
	genfile::bgen::IndexQuery::GenomicRange parse_range( std::string const& spec ) const {
		std::size_t colon_pos = spec.find( ':' ) ;
		if ( colon_pos == std::string::npos ) {
			throw std::invalid_argument( "spec=\"" + spec + "\"" ) ;
		}

		std::vector< std::string > pieces ;
		pieces.push_back( spec.substr( 0, colon_pos )) ;
		pieces.push_back( spec.substr( colon_pos+1, spec.size() )) ;

		if( pieces.size() != 2 ) {
			throw std::invalid_argument( "spec=\"" + spec + "\"" ) ;
		}

		std::size_t separator_pos = pieces[1].find( '-' ) ;
		if ( separator_pos == std::string::npos ) {
			throw std::invalid_argument( "spec=\"" + spec + "\"" ) ;
		}

		std::string chromosome( pieces[0] ) ;
		int pos1 = (separator_pos == 0) ? 0 : std::stoi( pieces[1].substr( 0, separator_pos ) ) ;
		int pos2 = (separator_pos == (pieces[1].size()-1)) ? std::numeric_limits< int >::max() : std::stoi( pieces[1].substr( separator_pos + 1, pieces[1].size() ) ) ;
		assert( pos1 >= 0 ) ;
		assert( pos2 >= pos1 ) ;

		return genfile::bgen::IndexQuery::GenomicRange( chromosome, pos1, pos2 ) ;
	}
} ;

int main( int argc, char** argv ) {
	try {
		MFMApplication app( argc, argv ) ;
	}
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}

