
//          Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#include <string>
#include <iostream>
#include "appcontext/CmdLineOptionProcessor.hpp"
#include "appcontext/ApplicationContext.hpp"
#include "config/qctool_version_autogenerated.hpp"
#include "genfile/SNPDataSource.hpp"
#include "genfile/SNPDataSourceChain.hpp"
#include "db/Error.hpp"

namespace globals {
	std::string const program_name = "hptest" ;
	std::string const program_version = qctool_version ;
	std::string const program_revision =  std::string( qctool_revision ).substr( 0, 7 ) ;
}

struct HPTestOptions: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;
		options.set_spec_option( "-spec" ) ;

		// File options
		options.declare_group( "Input file options" ) ;
	    options[ "-gh" ]
	        .set_description( 	"Path to host genotype files."
								"The given filename may contain the wildcard character '#', which expands to match a"
								"one- or two-character chromosome identifier." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1 ) ;

		options[ "-gp" ]
			.set_description(
				"Path to parasite genotype files."
				"The given filename may contain the wildcard character '#', which expands to match a"
				"one- or two-character chromosome identifier." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1 ) ;

	    options[ "-ghfiletype" ]
			.set_description(
				"Specify the filetype of the genotype files specified by -gh. "
				"By default, qctool will guess the file type.  Use this option to override that guess. "
				"Possible types are: \"" + genfile::string_utils::join( genfile::SNPDataSource::get_file_types(), "\",\"" ) + "\"." )
			.set_takes_single_value()
			.set_default_value( "guess" ) ;

	    options[ "-gpfiletype" ]
			.set_description(
				"Specify the filetype of the genotype files specified by -gp. "
				"By default, qctool will guess the file type.  Use this option to override that guess. "
				"Possible types are: \"" + genfile::string_utils::join( genfile::SNPDataSource::get_file_types(), "\",\"" ) + "\"." )
			.set_takes_single_value()
			.set_default_value( "guess" ) ;
		
	    options[ "-s" ]
	        .set_description( "Path of sample file" )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 1 ) ;
		
		options.declare_group( "Model options" ) ;
		options[ "-model" ]
			.set_description( "Model to fit" )
			.set_takes_values(1)
			.set_default_value( "gp ~ gh" )
		;
	}
} ;


struct HPTestApplication: public appcontext::ApplicationContext
{
public:
	HPTestApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version + ", revision " + globals::program_revision,
			std::auto_ptr< appcontext::OptionProcessor >( new HPTestOptions ),
			argc,
			argv,
			"-log"
		)
	{
		process() ;
	}
	
private:
	
	void process() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			get_ui_context().logger() << "!! Error (" << e.what() << "): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileNotFoundError const& e ) {
			get_ui_context().logger() << "\nError: No file matching \"" << e.filespec() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( db::Error const& e ) {
			get_ui_context().logger() << "!! Error (" << e.what() << ") with the following statement: \""
				<< e.sql()
				<< "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	void unsafe_process() {
		using genfile::string_utils::to_string ;
		
		genfile::SNPDataSource::UniquePtr
			host = open_snp_data_sources( options().get< std::string >( "-gh" )) ;
		genfile::SNPDataSource::UniquePtr
			para = open_snp_data_sources( options().get< std::string >( "-gp" )) ;
		genfile::CohortIndividualSource::UniquePtr
			samples = genfile::CohortIndividualSource::create( options().get< std::string >( "-s" ) ) ;

		std::size_t const N = samples->get_number_of_individuals() ;
		if( host->number_of_samples() != N ) {
			throw genfile::BadArgumentError(
				"HPTestApplication::unsafe_process()",
				"-gh \"" + options().get< std::string >( "-gh" ) + "\"",
				"Wrong number of samples (" + to_string(host->number_of_samples()) + ", expected " + to_string(N) + ")"
			) ;
		}
		if( para->number_of_samples() != N ) {
			throw genfile::BadArgumentError(
				"HPTestApplication::unsafe_process()",
				"-gp \"" + options().get< std::string >( "-gp" ) + "\"",
				"Wrong number of samples (" + to_string(para->number_of_samples()) + ", expected " + to_string(N) + ")"
			) ;
		}

		write_preamble( *host, *para, *samples ) ;
	}
	
	void write_preamble(
		genfile::SNPDataSource const& host,
		genfile::SNPDataSource const& para,
		genfile::CohortIndividualSource const& samples
	) {
		get_ui_context().logger() << "Loaded data for " << samples.size() << " samples.\n" ;
		get_ui_context().logger() << "    Host data:\n" << host.get_summary() << "\n" ;
		get_ui_context().logger() << "Parasite data:\n" << para.get_summary() << "\n" ;
		get_ui_context().logger() << "\n" << "Fitting model: " << options().get< std::string >( "-model" ) ;
	}
	
	genfile::SNPDataSource::UniquePtr open_snp_data_sources( std::string const& filename ) {
		std::vector< genfile::wildcard::FilenameMatch > filenames
			= genfile::wildcard::find_files_by_chromosome(
				filename,
				genfile::wildcard::eALL_CHROMOSOMES
			) ;

		genfile::SNPDataSourceChain::UniquePtr source = genfile::SNPDataSourceChain::create(
			filenames
		) ;
		
		return genfile::SNPDataSource::UniquePtr( source.release() ) ;
	}
} ;

int main( int argc, char** argv ) {
    try {
		HPTestApplication app( argc, argv ) ;
    }
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}

